`
Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"

Для удаления свойства мы можем использовать оператор delete
delete user.age;
Объект, объявленный как константа, может быть изменён
`

`
Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
`

`
Вместо name:name мы можем написать просто name:

function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}
Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).
Все другие типы данных будут автоматически преобразованы к строке.
Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0"
Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение

Для проверки нахождения ключа в объекте
"key" in object
In нужен для проверки когда поле на объекте существует но его значение - undefined

Для перебора всех свойств объекта используется цикл for..in
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}
Cвойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания
`

`
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
Два объекта равны только в том случае, если это один и тот же объект.
let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false
`

`
Чтобы скопировать объект можно написать фукнкцию или использовать Object.assign
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
`

`
Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
Возвращает объект dest.
Если скопированное имя свойства уже существует, оно будет перезаписано.
`

`
Существует базовое множество достижимых значений, которые не могут быть удалены.

Например:

Выполняемая в данный момент функция, её локальные переменные и параметры.
Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
Глобальные переменные.
(некоторые другие внутренние значения)
Эти значения мы будем называть корнями.

Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. 
`

`
Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

Сборщик мусора «помечает» (запоминает) все корневые объекты.
Затем он идёт по ним и «помечает» все ссылки из них.
Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
…И так далее, пока не будут посещены все достижимые (из корней) ссылки.
Все непомеченные объекты удаляются.
`

`
// сокращённая запись методов
user = {
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
  }
};
Для доступа к информации внутри объекта метод может использовать ключевое слово this
Значение this – это объект «перед точкой», который используется для вызова метода
Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj.
Вызов без объекта: this == undefined
Если внутри функции используется this, тогда она ожидает, что будет вызвана в контексте какого-либо объекта.
В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает метод (какой объект стоит «перед точкой»).
У стрелочных функций нет «this»
`

`
Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна выполняться только с помощью оператора "new"

Когда функция вызывается как new User(...), происходит следующее:
Создаётся новый пустой объект, и он присваивается this.
Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
Возвращается значение this.
`
function User(name) {
    // this = {};  (неявно)
  
    // добавляет свойства к this
    this.name = name;
    this.isAdmin = false;
  
    // return this;  (неявно)
}

`Другими словами, return в конструкторе с объектом возвращает этот объект, во всех остальных случаях возвращается this.
К примеру, здесь return замещает this, возвращая объект
`
function BigUser() {

    this.name = "John";
  
    return { name: "Godzilla" };  // <-- возвращает этот объект
  }
  
  alert( new BigUser().name );  // Godzilla, получили этот объект


`
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
Опциональная цепочка ?. не имеет смысла в левой части присваивания.
let user = null;

user?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"
`

`
В качестве ключа в объектах могут использоваться только строки и символы
Создаются новые символы с помощью функции Symbol():

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
Символы не преобразуются автоматически в строки

let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так
Символы игнорируются циклом for…in
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key)
Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key
`

`
результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!
ПРЕОБРАЗОВАНИЕ ОБЪЕКТОВ
Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
>, < использует хинт number то есть пробует конвертнуть объект к числу
`

`
Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:

Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
Иначе, если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.
`

/* let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500 */

`Преобразование может вернуть любой примитивный тип`