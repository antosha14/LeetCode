`
Функция которая загрузиот в док новый скрипт

function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.
`

`
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}
Такое написание называют асинхронным программированием с использованием колбэков. В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback
`

`
Опять же, подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).

Правила таковы:

Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
`

`
Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:

Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. В нашей аналогии это – «певец».
Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
`

`
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});
Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки.
У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
`

`
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.
Finaly не принимает аргументы
Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам
Единственным исключением из этого правила является случай, когда обработчик finally выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.
`

`
Поток выполнения такой:
Начальный промис успешно выполняется через 1 секунду (*),
Затем вызывается обработчик в .then (**).
Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
…и так далее.
Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
`

`
Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.
`

`
promise.then(f1).catch(f2);
Не идентично
promise.then(f1, f2);
Так как в первом примере catch также словит ошибку в F1
"Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.
Кетч если норм отраббатывает то даёт управление обратно к следующему за ним then
`

`
ЕСЛИ ОШИБКА НЕ БЫЛА ОБРАБОТАНА ТО БУДЕТ ИВЕНТ НА ОКНЕ unhandledrejection
В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
`

`
Методы Promise
1. Promise.all() - несколько промисов и подождать пока выполнятся ВСЕ! принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис. Eго результатом будет массив их результатов. ЛЮБОЙ ИЗ ПРОМИССОВ ОШИБКА - ВЕРНЁТ ОШИБКУ СРАЗУ КАК ЕЁ УВИДИТ.
Если в массиве, переданном в all будет не промис, то конечный массив будет содержать само это значение
2. Promise.allSettled() всегда ждёт завершения всех промисов. В массиве результатов будет {status:"fulfilled", value:результат} для успешных завершений,{status:"rejected", reason:ошибка} для ошибок.
3. Promise.race() ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
4. Promise.any() ждёт первый успешный. Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.
5. Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
6. Promise.reject(error) создаёт промис, завершённый с ошибкой error.
`

`
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
`

`
Промиссификация (обёртка функции в промис)
// promisify(f, true), чтобы получить массив результатов
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // наш специальный колбэк для f
        if (err) {
          reject(err);
        } else {
          // делаем resolve для всех results колбэка, если задано manyArgs
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// использование:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...)
Также существуют модули с более гибкой промисификацией, например, es6-promisify или встроенная функция util.promisify в Node.js.
`


`
Обработчики промисов .then/.catch/.finally всегда асинхронны.
Даже если промис виполнится сразу, сначала будет выполнен синхронный код после промиса
Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» (термин V8).

Как сказано в спецификации:

Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
Выполнение задачи происходит только в том случае, если ничего больше не запущено.
`