`
ЗАМЫКАНИЕ
Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока
С помощью блоков {...} мы можем изолировать часть кода, выполняющую свою собственную задачу, с переменными, принадлежащими только ей
Для if, for, while и т.д. переменные, объявленные в блоке кода {...}, также видны только внутри:
`
`
В JavaScript у каждой выполняемой функции, блока кода {...} и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
Объект лексического окружения состоит из двух частей:

Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта»
Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
Работа с переменными – это на самом деле работа со свойствами этого объекта.
Функция – это тоже значение, как и переменная.

Разница заключается в том, что Function Declaration мгновенно инициализируется полностью.
Когда запускается функция, в начале ее вызова автоматически создается новое лексическое окружение для хранения локальных переменных и параметров вызова.
Все функции помнят лексическое окружение, в котором они были созданы. Технически здесь нет никакой магии: все функции имеют скрытое свойство [[Environment]], которое хранит ссылку на лексическое окружение, в котором была создана функция
Ссылка на [[Environment]] устанавливается один раз и навсегда при создании функции.
Переменная обновляется в том лексическом окружении, в котором она существует.
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Все функции в JS это замыкания. Формально при создании функции у функции есть спеец свойство ENV в котором и хранится ссылка на окружение, где она была создана
Обычно лексическое окружение удаляется из памяти вместе со всеми переменными после завершения вызова функции

БАГ V8
function f() {
  let value = Math.random();

  function g() {
    debugger; // в консоли: напишите alert(value); Такой переменной нет!
  }

  return g;
}

let g = f();
g();
`

`
ПОКАЖЕТ PETE то есть последнее доступноее значение лексического окружения
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"?
`

`
function sum(a) {

  return function(b) {
    return a + b; // берёт "a" из внешнего лексического окружения
  };

}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1) ); // 4
`

`
let x = 1;

function func() {
  // локальная переменная x известна движку с самого начала выполнения функции,
  // но она является неинициализированной до let ("мёртвая зона")
  // следовательно, ошибка
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 2;
}

func();
`


`
Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000
Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).
Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.
Один вызов функции имеет ровно один контекст выполнения, связанный с ним
Выполнение текущей функции приостанавливается.
Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

Текущий контекст «запоминается» на вершине стека.
Создаётся новый контекст для вложенного вызова.
Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается, и выполнение соответствующей функции продолжается.

СВЯЗАННЫЙ СПИСОК, элемент хранит данные только о следующем соответственно переиндексация не дорогая
Элемент связанного списка определяется рекурсивно как объект с:
value,
next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
`

`
Но между Array.from(obj) и [...obj] есть разница:

Array.from работает как с псевдомассивами, так и с итерируемыми объектами
Оператор расширения работает только с итерируемыми объектами
`

`
В JavaScript функции – это объекты
У функций как и у объектов есть свойства например свойство name
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
если функция не имеет name, то JavaScript пытается определить его из контекста
Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении.
Троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»
`

`
На функции тоже можно задавать свойства
function sayHi() {
  alert("Hi");

  // давайте посчитаем, сколько вызовов мы сделали
  sayHi.counter++;
}
Свойство не есть переменная
Свойство функции, назначенное как sayHi.counter = 0, не объявляет локальную переменную counter внутри неё. Другими словами, свойство counter и переменная let counter – это две независимые вещи.

Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот. Это два параллельных мира.
`

`
NFE Named Function expression
let sayHi = function func(who) {
  alert(Hello, ${who});
};
Есть две важные особенности имени func, ради которого оно даётся:

Оно позволяет функции ссылаться на себя же.
Оно не доступно за пределами функции.
Нужно для того, чтобы всё работало даже если имя переменной изменится
let sayHi = function(who) {
  if (who) {
    alert(Hello, ${who});
  } else {
    sayHi("Guest"); // Ошибка: sayHi не является функцией
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Ошибка, вложенный вызов sayHi больше не работает!
`

`
let sayHi = new Function('alert("Hello")');
функция создаётся полностью «на лету» из строки, переданной во время выполнения.
когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.
`

let timerId = setTimeout(func|code, [delay], [arg1], [arg2]);
`
Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.
let timerId = setTimeout(...);
clearTimeout(timerId);
`
let timerId2 = setInterval(func|code, [delay], [arg1], [arg2] );
//Для setInterval функция остаётся в памяти до тех пор, пока не будет вызван clearInterval

`
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).

Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.
setTimeout(() => alert("Мир"));
alert("Привет");
Любой вызов setTimeout будет выполнен только после того, как текущий код завершится.
`

`
Существует специальный встроенный метод функции func.call(context, …args), который позволяет вызывать функцию, явно устанавливая this.
func.call(context, arg1, arg2, ...)
`

`
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

alert( worker.slow(2) ); // работает
alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)
Теперь всё в порядке.

Чтобы всё было понятно, давайте посмотрим глубже, как передаётся this:

После декорации worker.slow становится обёрткой function (x) { ... }.
Так что при выполнении worker.slow(2) обёртка получает 2 в качестве аргумента и this=worker (так как это объект перед точкой).
Внутри обёртки, если результат ещё не кеширован, func.call(this, x) передаёт текущий this (=worker) и текущий аргумент (=2) в оригинальную функцию.
func.apply(context, args) принимает в качестве аргументов псевдомассив
`

`
function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
Этот трюк называется заимствование метода.
Мы берём (заимствуем) метод join из обычного массива [].join. И используем [].join.call, чтобы выполнить его в контексте arguments.

`

`
При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря this.
`

`
Ytkmpz ldjqyjq иштв
function f() {
  alert(this.name);
}

f = f.bind( {name: "Вася"} ).bind( {name: "Петя"} );

f(); // Вася
`

`
В свойство функции записано значение. Изменится ли оно после применения bind? Обоснуйте ответ.

function sayHi() {
  alert( this.name );
}
sayHi.test = 5;

let bound = sayHi.bind({
  name: "Вася"
});

alert( bound.test ); // что выведет? почему?
решение
Ответ: undefined.

Результатом работы bind является другой объект. У него уже нет свойства test.
`
