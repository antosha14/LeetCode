num.toString(16)
Math.floor() // вниз
Math.ceil() // вверх
Math.round() // стандарт
Math.trunc() // просто убирает дробную часть
Math.random()
Math.max()
Math.pow(n, power) // Возвращает число n, возведённое в степень power
num.toFixed(1) // округление до n после запятой, вернёт строку
isNaN(NaN)
alert( NaN === NaN ); // Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе
isFinite(value) // Проверит на инфинити
Number.isNaN() // Строгие версии, сначала выполнят проверку на то является ли аргумент числом
Number.isFinite() // Строгие версии, сначала выполнят проверку на то является ли аргумент числом
alert( parseInt('100px') ); // 100 вернут NaN, если не смогли прочитать ни одну цифру: Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления
alert( parseFloat('12.5em') ); // 12.5 вернут NaN, если не смогли прочитать ни одну цифру:
alert( `My\n`.length ); // 3 в ЖАЭС без скобок
str.at(-1) // вместо разреза так как от с отрицательными возвращает undefined
'Interface'.toUpperCase()
'Interface'.toLowerCase()
'Interface'[0].toLowerCase() // 'i'
`В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.`
str.slice(start [, end]) //Возвращает часть строки от start до (не включая) end
str.substring(start [, end]) //Возвращает часть строки между start и end (не включая) end.
str.substr(start [, length]) //Возвращает часть строки от start длины length.
str.codePointAt(pos) //Возвращает код для символа, находящегося на позиции pos
String.fromCodePoint(code) //Создаёт символ по его коду code
fruits.pop() //Удаляем из конца и выводим
fruits.push("Груша") // Добавляем элемент в конец массива
fruits.shift() // удаляем первый и выводи его
fruits.unshift('Яблоко') // Добавляем элемент в начало массива 
// length массива это самый большой индекс плюс 1
// length можно менять но если увеличим ничего не будет а если уменьшим то массив уменьшится
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
arr.splice(0, 3, "Давай", "танцевать"); // splice возвращает массив из удалённых элементов
arr.slice(1, 3) //возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end)
//Можно вызвать slice без аргументов: arr.slice() создаёт копию arr
arr.concat(arg1, arg2)
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});

`
arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
Метод arr.lastIndexOf похож на indexOf, но ищет справа налево
Методы используют строгое сравнение
Метод includes правильно обрабатывает NaN в то время как indexOf вернёт -1 всегда
`
// если нужно найти объект в массиве с определёнными условиями
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
//У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам элемент. И -1 если ничего не было найдено

let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});

arr.sort();
`Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов, По умолчанию элементы сортируются как строки. Ниже функция для сортировки чисел`

function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15
arr.sort(function(a, b) { return a - b; });
arr.reverse();
str.split(delim)
//Вызов split(s) с пустым аргументом s разбил бы строку на массив букв
arr.join(';')
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
arr.reduceRight
Array.isArray({}) //Так как typeof не отличает массивы от объектов
`Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg. Кторый ссодержит в себе this`

`
arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск
`

`
Первый метод — str.indexOf(substr, pos).
Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
str.lastIndexOf(substr, position)
`

`
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.
`

`
Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой
`

`52 бита на цифры и 11 на положение точки и 1 на хранение знака, если больше то вернёт Infinity`

`
let str = "Привет";

alert( str.toUpperCase() ); // ПРИВЕТ
Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
Этот метод запускается и возвращает новую строку (показывается в alert).
Специальный объект удаляется, оставляя только примитив str.
null/undefined не имеют методов
`

`
let str = "Привет";

str.test = 5; // (*)

alert(str.test);
В зависимости от того, используете ли вы строгий режим (use strict) или нет, результат может быть:

undefined (без strict)
Ошибка (strict mode)
Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):

В момент обращения к свойству str создаётся «объект-обёртка».
В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
Без строгого режима, операция продолжается, объект получает свойство test, но после этого он удаляется, так что на последней линии str больше не имеет свойства test.
Данный пример наглядно показывает, что примитивы не являются объектами.
`

`
Диапазон BIGINT (2 в 53-1) или менее чем -(2 в 53-1)\
Мы также можем использовать символ нижнего подчёркивания _ в качестве разделителя:
let billion = 1_000_000_000
e умножает число на 1 с указанным количеством нулей
alert( 7.3e9 );  // 7.3 миллиарда (7,300,000,000)

// 1 делится на 1 с 3 нулями
1e-3 === 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 === 1.23 / 1000000 (=0.00000123)
Шестнадцатиричные, 36  двоичные  и восьмеричные
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
`

`
Вызов методов напряямую на числе делается с двумя точками
alert( 123456..toString(36) ); // 2n9c
`

`
alert( 0.1 + 0.2 == 0.3 ); // false
пустая строка интерпретируется как 0 во всех числовых функциях
`

`
Также можно перебрать строку посимвольно, используя for..of
Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.
`

`
метод	выбирает…	отрицательные значения
slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end (не включая end)	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным
`

`
Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.
`

`
Случайная сортировка но с ошибкой (алгоритм сходит с ума)
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

Без ошибки
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i
    [array[i], array[j]] = [array[j], array[i]];
  }
}
`