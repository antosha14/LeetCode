@tsignore
`
Кривая Безье задаётся опорными точками.
Если вы посмотрите внимательно на эти кривые, то «на глазок» заметите:
Точки не всегда на кривой. Это совершенно нормально, как именно строится кривая мы рассмотрим чуть позже.
Степень кривой равна числу точек минус один. Для двух точек – это линейная кривая (т.е. прямая), для трёх точек – квадратическая кривая (парабола), для четырёх – кубическая.
Кривая всегда находится внутри выпуклой оболочки, образованной опорными точками

Построение кривой Безье с 3 точками по «алгоритму де Кастельжо»:

1. Рисуются опорные точки. В примере это: 1, 2, 3.

2. Строятся отрезки между опорными точками в следующем порядке 1 → 2 → 3. На рисунке они коричневые.

3. Параметр t «пробегает» значения от 0 до 1. В примере использован шаг 0.05, т.е. в цикле 0, 0.05, 0.1, 0.15, ... 0.95, 1.
    Для каждого из этих значений t:
        На каждом из коричневых отрезков берётся точка, находящаяся на расстоянии, пропорциональном t, от его начала. Так как отрезков два, то и точек две.
        Например, при t=0 – точки будут в начале, при t=0.25 – на расстоянии в 25% от начала отрезка, при t=0.5 – 50% (на середине), при t=1 – в конце отрезков.
    Эти точки соединяются. На рисунке ниже соединяющий их отрезок изображён синим.

4) На получившемся синем отрезке берётся точка на расстоянии, соответствующем t. То есть, для t=0.25 (левый рисунок) получаем точку в конце первой четверти отрезка, для t=0.5 (правый рисунок) – в середине отрезка. На рисунках выше эта точка отмечена красным.

5) По мере того, как t «пробегает» последовательность от 0 до 1, каждое значение t добавляет к кривой точку. Совокупность таких точек для всех значений образует кривую Безье. Она красная и имеет параболическую форму на картинках выше.

Координаты кривой с опорными точками Pi: первая опорная точка имеет координаты P1 = (x1, y1), вторая: P2 = (x2, y2) и т.д., описываются уравнением, зависящим от параметра t на отрезке [0,1].

Формула для 2-х точечной кривой:
P = (1-t)P1 + tP2

Для 3 опорных точек:
P = (1−t)2P1 + 2(1−t)tP2 + t2P3

Для 4 опорных точек:
P = (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4

ИТОГО
Кривые Безье задаются опорными точками.
Мы рассмотрели два определения кривых:

Через математическую формулу.
Использование процесса рисования: алгоритм де Кастельжо.
Их удобство в том, что:

Можно рисовать плавные линии с помощью мыши, перемещая опорные точки.
Сложные формы могут быть сделаны из нескольких кривых Безье.
Применение:

В компьютерной графике, моделировании, в графических редакторах. Шрифты описываются с помощью кривых Безье.
В веб-разработке – для графики на Canvas или в формате SVG. Кстати, все живые примеры выше написаны на SVG. Фактически это один SVG-документ, к которому точки передаются параметрами. Вы можете открыть его в отдельном окне и посмотреть исходник: demo.svg.
В CSS-анимации для задания траектории или скорости передвижения.    
`

`
CSS анимации

.animated {
  transition-property: background-color;
  transition-duration: 3s;
}

Существует 4 свойства для описания CSS-переходов:
transition-property – свойство перехода
transition-duration – продолжительность перехода
transition-timing-function – временная функция перехода
transition-delay – задержка начала перехода

Далее мы рассмотрим их все, а сейчас ещё заметим, что есть также общее свойство transition, которое позволяет задать их одновременно в последовательности: property duration timing-function delay,

Отрицательные значения также допустимы. В таком случае анимация начнётся с середины. Например, если transition-duration равно 2s, а transition-delay – -1s, тогда анимация займёт одну секунду и начнётся с середины.

Для анимации движения элемента
transform: translate(-90%);
transition-property: transform;

Синтаксис для кривых Безье в CSS: cubic-bezier(x2, y2, x3, y3).
Есть несколько встроенных обозначений кривых Безье: linear, ease, ease-in, ease-out и ease-in-out.
Кривая Безье может заставить анимацию «выпрыгивать» за пределы диапазона.
Например изображение может двигаться назад

Как мы знаем, ось y измеряет «завершённость процесса анимации». Значение y = 0 соответствует начальному значению анимируемого свойства и y = 1 – конечному значению. Таким образом, y<0 делает значение свойства left меньше начального значения и y>1 – больше конечного.
Временная функция steps(количество шагов[, start/end]) позволяет разделить анимацию на шаги

#stripe.animate  {
  transform: translate(-90%);
  transition: transform 9s steps(9, start);
} start – означает, что в начале анимации нам необходимо перейти на первый шаг немедленно, если end, то первый шаг тоже будет ждать время анимации

Когда завершается анимация, срабатывает событие transitionend. event.propertyName - анимация чего завершилась.event.elapsedTime - Время (в секундах), которое заняла анимация, без учёта transition-delay

Мы можем объединить несколько простых анимаций вместе, используя CSS-правило @keyframes.

Оно определяет «имя» анимации и правила: что, когда и где анимировать. После этого можно использовать свойство animation, чтобы назначить анимацию на элемент и определить её дополнительные параметры.

<div class="progress"></div>

<style>
  @keyframes go-left-right {        /* объявляем имя анимации: "go-left-right" */
    from { left: 0px; }             /* от: left: 0px */
    to { left: calc(100% - 50px); } /* до: left: 100%-50px */
  }

  .progress {
    animation: go-left-right 3s infinite alternate;
    /* применить анимацию "go-left-right" на элементе
       продолжительностью 3 секунды
       количество раз: бесконечно (infinite)
       менять направление анимации каждый раз (alternate)
    */

    position: relative;
    border: 2px solid green;
    width: 50px;
    height: 20px;
    background: lime;
  }
</style>
`

`
JS анимации

let start = Date.now(); // запомнить время начала
let timer = setInterval(function() {
  // сколько времени прошло с начала анимации?
  let timePassed = Date.now() - start;

  if (timePassed >= 2000) {
    clearInterval(timer); // закончить анимацию через 2 секунды
    return;
  }

  // отрисовать анимацию на момент timePassed, прошедший с начала анимации
  draw(timePassed);

}, 20);

// в то время как timePassed идёт от 0 до 2000
// left изменяет значение от 0px до 400px
function draw(timePassed) {
  train.style.left = timePassed / 5 + 'px';
}

Несколько анимаций, и не делать их если вкладкка закрыта
let requestId = requestAnimationFrame(callback) Такой вызов планирует запуск функции callback на ближайшее время, когда браузер сочтёт возможным осуществить анимацию.
Если в callback происходит изменение элемента, тогда оно будет сгруппировано с другими requestAnimationFrame и CSS-анимациями. Таким образом браузер выполнит один геометрический пересчёт и отрисовку, вместо нескольких.

// отмена запланированного запуска callback
cancelAnimationFrame(requestId);

function animate({duration, draw, timing}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    let progress = timing(timeFraction)

    draw(progress);

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
  
Вместо передвижения элемента мы можем делать что-нибудь ещё. Всё, что нам нужно – это правильно написать функцию draw

 function animateText(textArea) {
      let text = textArea.value;
      let to = text.length,
      from = 0;

      animate({
        duration: 5000,
        timing: bounce,
        draw: function(progress) {
          let result = (to - from) * progress + from;
          textArea.value = text.slice(0, Math.ceil(result))
        }
      });
    }


    function bounce(timeFraction) {
      for (let a = 0, b = 1; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
      }
    }

JavaScript может помочь в тех случаях, когда CSS не справляется или нужен жёсткий контроль над анимацией. JavaScript-анимации должны быть сделаны с помощью requestAnimationFrame. Это встроенный метод браузера, который вызывает переданную в него функцию в тот момент, когда браузер готовится совершить перерисовку (обычно это происходит быстро, но конкретные задержки зависят от браузера).

Когда вкладка скрыта, на ней совсем не происходит перерисовок, и функция не будет вызвана: анимация будет приостановлена и не потратит ресурсы. Это хорошо.

Вспомогательная функция animate для создания анимации:

function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction изменяется от 0 до 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // вычисление текущего состояния анимации
    let progress = timing(timeFraction);

    draw(progress); // отрисовать её

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
Опции:

duration – общая продолжительность анимации в миллисекундах.
timing – функция вычисления прогресса анимации. Получается момент времени от 0 до 1, возвращает прогресс анимации, обычно тоже от 0 до 1.
draw – функция отрисовки анимации.
Конечно, мы могли бы улучшить вспомогательную функцию и добавить в неё больше наворотов. Но JavaScript-анимации не каждый день используются, а только когда хотят сделать что-то интересное и необычное. Не стоит усложнять функцию до тех пор пока это вам не понадобились.

JavaScript-анимации могут использовать любые функции расчёта времени. Мы рассмотрели множество примеров и их вариаций, чтобы сделать их ещё более универсальными. В отличие от CSS, мы здесь не ограничены только кривой Безье.

То же самое и с draw: мы можем анимировать всё что угодно, не только CSS-свойства.
`