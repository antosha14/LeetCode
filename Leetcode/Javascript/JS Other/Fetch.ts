`
Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа. HTTP-статусы 404 и 500 не являются ошибкой

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

response.text() – читает ответ и возвращает как обычный текст,
response.json() – декодирует ответ в формате JSON,
response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
response.blob() – возвращает объект как Blob (бинарные данные с типом),
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.

Заголовки ответа хранятся в похожем на Map объекте response.headers
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// получить один заголовок
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(${key} = ${value});
}

let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
}); Есть заголовки которые мы не можем проставить


let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});


Типичный запрос с помощью fetch состоит из двух операторов await:

let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
Или, без await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
Параметры ответа:

response.status – HTTP-код ответа,
response.ok – true, если статус ответа в диапазоне 200-299.
response.headers – похожий на Map объект с HTTP-заголовками.
Методы для получения тела ответа:

response.text() – возвращает ответ как обычный текст,
response.json() – декодирует ответ в формате JSON,
response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
response.blob() – возвращает объект как Blob (бинарные данные с типом),
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
Опции fetch, которые мы изучили на данный момент:

method – HTTP-метод,
headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.

let formData = new FormData([form]);
Его особенность заключается в том, что методы для работы с сетью, например fetch, позволяют указать объект FormData в свойстве тела запроса body.

Он будет соответствующим образом закодирован и отправлен с заголовком Content-Type: multipart/form-data.

С помощью указанных ниже методов мы можем изменять поля в объекте FormData:

formData.append(name, value) – добавляет к объекту поле с именем name и значением value,
formData.append(name, blob, fileName) – добавляет поле, как будто в форме имеется элемент <input type="file">, третий аргумент fileName устанавливает имя файла (не имя поля формы), как будто это имя из файловой системы пользователя,
formData.delete(name) – удаляет поле с заданным именем name,
formData.get(name) – получает значение поля с именем name,
formData.has(name) – если существует поле с именем name, то возвращает true, иначе false

Объекты FormData используются, чтобы взять данные из HTML-формы и отправить их с помощью fetch или другого метода для работы с сетью.

Мы можем создать такой объект уже с данными, передав в конструктор HTML-форму – new FormData(form), или же можно создать объект вообще без формы и затем добавить к нему поля с помощью методов:

formData.append(name, value)
formData.append(name, blob, fileName)
formData.set(name, value)
formData.set(name, blob, fileName)
Отметим две особенности:

Метод set удаляет предыдущие поля с таким же именем, а append – нет. В этом их единственное отличие.
Чтобы послать файл, нужно использовать синтаксис с тремя аргументами, в качестве третьего как раз указывается имя файла, которое обычно, при <input type="file">, берётся из файловой системы.
Другие методы:

formData.delete(name)
formData.get(name)
formData.has(name)

Файл можно передавать как отдельную часть формы
через 
let formData = new FormData();
formData.append("firstName", "John");
formData.append("image", imageBlob, "image.png");

Чтобы отслеживать ход загрузки данных с сервера, можно использовать свойство response.body. Это ReadableStream («поток для чтения») – особый объект, который предоставляет тело ответа по частям, по мере поступления. Потоки для чтения описаны в спецификации Streams API.
`

// вместо response.json() и других методов
const reader = response.body.getReader();

// бесконечный цикл, пока идёт загрузка
while(true) {
  // done становится true в последнем фрагменте
  // value - Uint8Array из байтов каждого фрагмента
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Получено ${value.length} байт`)
}

`
Для отмены асинхронных задач существует специальный встроенный объект: AbortController, который можно использовать для отмены не только fetch, но и других асинхронных задач

let controller = new AbortController();
Контроллер controller – чрезвычайно простой объект.

Он имеет единственный метод abort() и единственное свойство signal.
При вызове abort():
генерируется событие с именем abort на объекте controller.signal
свойство controller.signal.aborted становится равным true.

Вот так (пока без fetch):

let controller = new AbortController();
let signal = controller.signal;

// срабатывает при вызове controller.abort()
signal.addEventListener('abort', () => alert("отмена!"));

controller.abort(); // отмена!

alert(signal.aborted); // true
Шаг 2: передайте свойство signal опцией в метод fetch:

let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});
Метод fetch умеет работать с AbortController, он слушает событие abort на signal.

Шаг 3: чтобы прервать выполнение fetch, вызовите controller.abort():

controller.abort();

Когда fetch отменяется, его промис завершается с ошибкой AbortError, поэтому мы должны обработать её, например, в try..catch

Позволяет отменить все fetch
let urls = [...]; // список URL для параллельных fetch
let controller = new AbortController();
let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));
let results = await Promise.all(fetchJobs);

Все возможности fetch
let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    // значение этого заголовка обычно ставится автоматически,
    // в зависимости от тела запроса
    "Content-Type": "text/plain;charset=UTF-8"
  },
  body: undefined, // string, FormData, Blob, BufferSource или URLSearchParams
  referrer: "about:client", // или "" для того, чтобы не послать заголовок Referer,
  // или URL с текущего источника
  referrerPolicy: "strict-origin-when-cross-origin", // no-referrer-when-downgrade, no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache или only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // контрольная сумма, например "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController, чтобы прервать запрос
  window: window // null
});
Опция referrer позволяет установить любой Referer в пределах текущего источника или же убрать его.
keepalive: true если нужно отправить что-то после закрытия страницы
Обычно, когда документ выгружается, все связанные с ним сетевые запросы прерываются. Но настройка keepalive указывает браузеру выполнять запрос в фоновом режиме даже после того, как пользователь покидает страницу. Поэтому эта опция обязательна, чтобы такой запрос удался.

Простие и непростые запросы. Принципиальное отличие между ними состоит в том, что «простой запрос» может быть сделан через <form> или <script>, без каких-то специальных методов

При запросе на другой источник браузер всегда ставит «от себя» заголовок Origin.

Например, если мы запрашиваем https://anywhere.com/request со страницы https://javascript.info/page, заголовки будут такими:

GET /request
Host: anywhere.com
Origin: https://javascript.info
...

По умолчанию при запросе к другому источнику JavaScript может получить доступ только к так называемым «простым» заголовкам ответа:

Cache-Control
Content-Language
Content-Length
Content-Type
Expires
Last-Modified
Pragma

Чтобы разрешить JavaScript доступ к любому другому заголовку ответа, сервер должен указать заголовок Access-Control-Expose-Headers. Он содержит список, через запятую, заголовков, которые не являются простыми, но доступ к которым разрешён

Предварительный запрос использует метод OPTIONS, у него нет тела, но есть три заголовка:

Origin содержит именно источник (домен/протокол/порт), без пути.
Access-Control-Request-Method содержит HTTP-метод «непростого» запроса.
Access-Control-Request-Headers предоставляет разделённый запятыми список его «непростых» HTTP-заголовков.

Если сервер согласен принимать такие запросы, то он должен ответить без тела, со статусом 200 и с заголовками:

Access-Control-Allow-Origin должен содержать разрешённый источник.
Access-Control-Allow-Methods должен содержать разрешённые методы.
Access-Control-Allow-Headers должен содержать список разрешённых заголовков.
Кроме того, заголовок Access-Control-Max-Age может указывать количество секунд, на которое нужно кешировать разрешения. Так что браузеру не придётся посылать предзапрос для последующих запросов, удовлетворяющих данным разрешениям.

Например, fetch('http://another.com') не посылает никаких куки, даже тех (!), которые принадлежат домену another.com.
Чтобы включить отправку авторизационных данных в fetch, нам нужно добавить опцию credentials: "include", вот так:
fetch('http://another.com', {
  credentials: "include"
});

С точки зрения браузера запросы к другому источнику бывают двух видов: «простые» и все остальные.

Простые запросы должны удовлетворять следующим условиям:

Метод: GET, POST или HEAD.
Заголовки – мы можем установить только:
Accept
Accept-Language
Content-Language
Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.
Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов <form> или <script>, в то время как непростые долгое время были невозможны для браузеров.

Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком Origin, а для других браузер делает предварительный запрос, спрашивая разрешения.

Для простых запросов:

→ Браузер посылает заголовок Origin с источником.
← Для запросов без авторизационных данных (не отправляются по умолчанию) сервер должен установить:
Access-Control-Allow-Origin в * или то же значение, что и Origin
← Для запросов с авторизационными данными сервер должен установить:
Access-Control-Allow-Origin в то же значение, что и Origin
Access-Control-Allow-Credentials в true
Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме Cache-Control, Content-Language, Content-Type, Expires, Last-Modified или Pragma, сервер должен перечислить разрешённые в заголовке Access-Control-Expose-Headers.

Для непростых запросов перед основным запросом отправляется предзапрос:

→ Браузер посылает запрос OPTIONS на тот же адрес с заголовками:
Access-Control-Request-Method – содержит запрашиваемый метод,
Access-Control-Request-Headers – перечисляет непростые запрашиваемые заголовки.
← Сервер должен ответить со статусом 200 и заголовками:
Access-Control-Allow-Methods со списком разрешённых методов,
Access-Control-Allow-Headers со списком разрешённых заголовков,
Access-Control-Max-Age с количеством секунд для кеширования разрешений
→ Затем отправляется основной запрос, применяется предыдущая «простая» схема.

let url1 = new URL('https://javascript.info/profile/admin');
let url2 = new URL('/profile/admin', 'https://javascript.info');
alert(url1); // https://javascript.info/profile/admin
alert(url2); // https://javascript.info/profile/admin

let url = new URL('https://javascript.info/url');
alert(url.protocol); // https:
alert(url.host);     // javascript.info
alert(url.pathname); // /url

Так что для этого есть свойство url.searchParams – объект типа URLSearchParams.

Он предоставляет удобные методы для работы с параметрами:

append(name, value) – добавить параметр по имени,
delete(name) – удалить параметр по имени,
get(name) – получить параметр по имени,
getAll(name) – получить все параметры с одинаковым именем name (такое возможно, например: ?user=John&user=Pete),
has(name) – проверить наличие параметра по имени,
set(name, value) – задать/заменить параметр,
sort() – отсортировать параметры по имени, используется редко,
…и является перебираемым, аналогично Map

Однако, если мы используем строку, то надо самим позаботиться о кодировании специальных символов.

Для этого есть встроенные функции:

encodeURI – кодирует URL-адрес целиком.
decodeURI – декодирует URL-адрес целиком.
encodeURIComponent – кодирует компонент URL, например, параметр, хеш, имя пути и т.п.
decodeURIComponent – декодирует компонент URL.

ОТСЛЕЖИВАНИЕ ПРОГРЕССА ЗАГРУЗКИ ФАЙЛА
let fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;
//Далее, посылаем запрос к серверу с просьбой указать количество уже полученных байтов:
let response = await fetch('status', {
  headers: {
    'X-File-Id': fileId
  }
});

// сервер получил столько-то байтов
let startByte = +await response.text();
//Затем мы можем использовать метод slice объекта Blob, чтобы отправить данные, начиная со startByte байта

xhr.open("POST", "upload");

// Идентификатор файла, чтобы сервер знал, что мы загружаем
xhr.setRequestHeader('X-File-Id', fileId);

// Номер байта, начиная с которого мы будем отправлять данные.
// Таким образом, сервер поймёт, с какого момента мы возобновляем загрузку
xhr.setRequestHeader('X-Start-Byte', startByte);

xhr.upload.onprogress = (e) => {
  console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
};

// файл file может быть взят из input.files[0] или другого источника
xhr.send(file.slice(startByte));

Длинные опросы 
Как это происходит:

Запрос отправляется на сервер.
Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.
Когда появляется сообщение – сервер отвечает на запрос, посылая его.
Браузер немедленно делает новый запрос.

Примерный код клиентской функции subscribe, которая реализует длинные опросы:

async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // Статус 502 - это таймаут соединения;
    // возможен, когда соединение ожидало слишком долго
    // и сервер (или промежуточный прокси) закрыл его
    // давайте восстановим связь
    await subscribe();
  } else if (response.status != 200) {
    // Какая-то ошибка, покажем её
    showMessage(response.statusText);
    // Подключимся снова через секунду.
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Получим и покажем сообщение
    let message = await response.text();
    showMessage(message);
    // И снова вызовем subscribe() для получения следующего сообщения
    await subscribe();
  }
}

subscribe();
`
let socket = new WebSocket("wss://javascript.info");

`
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.
Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:

open – соединение установлено,
message – получены данные,
error – ошибка,
close – соединение закрыто.
`
let socket2 = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error]`);
};

`
Когда new WebSocket(url) создан, он тут же сам начинает устанавливать соединение
Поток данных в WebSocket состоит из «фреймов», фрагментов данных, которые могут быть отправлены любой стороной, и которые могут быть следующих видов:

«текстовые фреймы» – содержат текстовые данные, которые стороны отправляют друг другу.
«бинарные фреймы» – содержат бинарные данные, которые стороны отправляют друг другу.
«пинг-понг фреймы» используется для проверки соединения; отправляется с сервера, браузер реагирует на них автоматически.
также есть «фрейм закрытия соединения» и некоторые другие служебные фреймы.

Свойство socket.bufferedAmount хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети.

// каждые 100мс проверить сокет и отправить больше данных,
// только если все текущие отосланы
setInterval(() => {
  if (socket.bufferedAmount == 0) {
    socket.send(moreData());
  }
}, 100);

socket.close(1000, "работа закончена");

// другая сторона:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "работа закончена"
  // event.wasClean === true (закрыто чисто)
};

Чтобы получить состояние соединения, существует дополнительное свойство socket.readyState со значениями:

0 – «CONNECTING»: соединение ещё не установлено,
1 – «OPEN»: обмен данными,
2 – «CLOSING»: соединение закрывается,
3 – «CLOSED»: соединение закрыто.

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.

Нет ограничений, связанных с кросс-доменными запросами.
Имеют хорошую поддержку браузерами.
Могут отправлять/получать как строки, так и бинарные данные.
API прост.

Методы:

socket.send(data),
socket.close([code], [reason]).
События:

open,
message,
error,
close.
WebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.

Иногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно используют одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.


Чтобы начать получать данные, нам нужно просто создать new EventSource(url)
data: Сообщение 1

data: Сообщение 2

data: Сообщение 3
data: в две строки

Текст сообщения указывается после data:, пробел после двоеточия необязателен.
Сообщения разделяются двойным переносом строки \n\n.
Чтобы разделить сообщение на несколько строк, мы можем отправить несколько data: подряд (третье сообщение).

Для каждого сообщения генерируется событие message:

let eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = function(event) {
  console.log("Новое сообщение", event.data);
  // этот код выведет в консоль 3 сообщения, из потока данных выше
};

Объект EventSource автоматически устанавливает постоянное соединение и позволяет серверу отправлять через него сообщения.

data: Сообщение 1
id: 1
id после data

Он предоставляет:

Автоматическое переподключение с настраиваемой retry задержкой.
Идентификаторы сообщений для восстановления соединения. Последний полученный идентификатор посылается в заголовке Last-Event-ID при пересоединении.
Текущее состояние, записанное в свойстве readyState.
Это делает EventSource достойной альтернативой протоколу WebSocket, который сравнительно низкоуровневый и не имеет таких встроенных возможностей (хотя их и можно реализовать).

Для многих приложений возможностей EventSource вполне достаточно.

Поддерживается во всех современных браузерах (кроме Internet Explorer).

Синтаксис:

let source = new EventSource(url, [credentials]);
Второй аргумент – необязательный объект с одним свойством: { withCredentials: true }. Он позволяет отправлять авторизационные данные на другие домены.

В целом, кросс-доменная безопасность реализована так же как в fetch и других методах работы с сетью.

Свойства объекта EventSource
readyState
Текущее состояние подключения: EventSource.CONNECTING (=0), EventSource.OPEN (=1) или EventSource.CLOSED (=2).
lastEventId
id последнего полученного сообщения. При переподключении браузер посылает его в заголовке Last-Event-ID.
Методы
close()
Закрывает соединение.
События
message
Сообщение получено, переданные данные записаны в event.data.
open
Соединение установлено.
error
В случае ошибки, включая как потерю соединения, так и другие ошибки в нём. Мы можем обратиться к свойству readyState, чтобы проверить, происходит ли переподключение.
Сервер может выставить собственное событие с помощью event:. Такие события должны быть обработаны с помощью addEventListener, а не on<event>.

Формат ответа сервера
Сервер посылает сообщения, разделённые двойным переносом строки \n\n.

Сообщение состоит из следующих полей:

data: – тело сообщения, несколько data подряд интерпретируются как одно сообщение, разделённое переносами строк \n.
id: – обновляет свойство lastEventId, отправляемое в Last-Event-ID при переподключении.
retry: – рекомендованная задержка перед переподключением в миллисекундах. Не может быть установлена с помощью JavaScript.
event: – имя пользовательского события, должно быть указано перед data:.
Сообщение может включать одно или несколько этих полей в любом порядке, но id обычно ставят в конце.

XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
`

let xhr = new XMLHttpRequest();

`
Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно отсылается запрос только лишь после вызова send

Событие progress срабатывает только на стадии загрузки ответа с сервера.

А именно: если мы отправляем что-то через POST-запрос, XMLHttpRequest сперва отправит наши данные (тело запроса) на сервер, а потом загрузит ответ сервера. И событие progress будет срабатывать только во время загрузки ответа.

Если мы отправляем что-то большое, то нас гораздо больше интересует прогресс отправки данных на сервер. Но xhr.onprogress тут не поможет.

Существует другой объект, без методов, только для отслеживания событий отправки: xhr.upload.

Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:

loadstart – начало загрузки данных.
progress – генерируется периодически во время отправки на сервер.
abort – загрузка прервана.
error – ошибка, не связанная с HTTP.
load – загрузка успешно завершена.
timeout – вышло время, отведённое на загрузку (при установленном свойстве timeout).
loadend – загрузка завершена, вне зависимости от того, как – успешно или нет.
`
xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP ошибка?
    // обработаем ошибку
    alert( 'Ошибка: ' + xhr.status);
    return;
  }

  // получим ответ из xhr.response
};

xhr.onprogress = function(event) {
  // выведем прогресс
  alert(`Загружено ${event.loaded} из ${event.total}`);
};

xhr.onerror = function() {
  // обработаем ошибку, не связанную с HTTP (например, нет соединения)
};

`
Событий на самом деле больше, в современной спецификации они все перечислены в том порядке, в каком генерируются во время запроса:

loadstart – начало запроса.
progress – прибыла часть данных ответа, тело ответа полностью на данный момент можно получить из свойства responseText.
abort – запрос был прерван вызовом xhr.abort().
error – произошла ошибка соединения, например неправильное доменное имя. Событие не генерируется для HTTP-ошибок как, например, 404.
load – запрос успешно завершён.
timeout – запрос был отменён по причине истечения отведённого для него времени (происходит, только если был установлен таймаут).
loadend – срабатывает после load, error, timeout или abort.
События error, abort, timeout и load взаимно исключают друг друга – может произойти только одно из них.

Наиболее часто используют события завершения загрузки (load), ошибки загрузки (error), или мы можем использовать единый обработчик loadend для всего и смотреть в свойствах объекта запроса xhr детали произошедшего.

Также мы уже видели событие: readystatechange. Исторически оно появилось одним из первых, даже раньше, чем была составлена спецификация. Сегодня нет необходимости использовать его, так как оно может быть заменено современными событиями, но на него можно часто наткнуться в старом коде.

Если же нам нужно следить именно за процессом отправки данных на сервер, тогда можно использовать те же события, но для объекта xhr.upload.
`
