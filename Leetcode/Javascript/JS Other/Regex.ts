`
regexp = /шаблон/gmi; // с флагами gmi (будут описаны далее)

new RegExp – когда мы хотим создать регулярное выражение «на лету» из динамически сгенерированной строки, например
let tag = prompt("Какой тег вы хотите найти?", "h2");

let regexp = new RegExp(`<${tag}>`); // то же, что /<h2>/  при ответе "h2" на prompt выше

i
С этим флагом поиск не зависит от регистра: нет разницы между A и a (см. пример ниже).
g
С этим флагом поиск ищет все совпадения, без него – только первое.
m
Многострочный режим (рассматривается в главе Многострочный режим якорей ^ $, флаг "m").
s
Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n (рассматривается в главе Символьные классы).
u
Включает полную поддержку Юникода. Флаг разрешает корректную обработку суррогатных пар (подробнее об этом в главе Юникод: флаг "u" и класс \p{...}).
y
Режим поиска на конкретной позиции в тексте (описан в главе Поиск на заданной позиции, флаг "y").
d
С этим флагом результат регулярного выражения помещается в массив, который содержит дополнительную информацию о регулярном выражении, например индексы начала и конца подстрок. Этот флаг не меняет поведение регулярного выражения, а лишь предоставляет дополнительную информацию.


Метод str.match(regexp) для строки str возвращает совпадения с регулярным выражением regexp

если совпадений нет, то, вне зависимости от наличия флага g, возвращается null.
Метод str.replace(regexp, replacement) заменяет совпадения с regexp в строке str на replacement (все, если есть флаг g, иначе только первое).
Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false

Регулярное выражение состоит из шаблона и необязательных флагов: g, i, m, u, s, y, d.
Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску подстроки.
Метод str.match(regexp) ищет совпадения: все, если есть флаг g, иначе только первое.
Метод str.replace(regexp, replacement) заменяет совпадения с regexp на replacement: все, если у регулярного выражения есть флаг g, иначе только первое.
Метод regexp.test(str) возвращает true, если есть хоть одно совпадение, иначе false.

Например, давайте найдём первую цифру в номере телефона:

let str = "+7(903)-123-45-67";
let regexp = /\d/;
alert( str.match(regexp) ); // 7

\d («d» от английского «digit» означает «цифра»)
Цифра: символ от 0 до 9.
\s («s»: от английского «space» – «пробел»)
Пробельные символы: включает в себя символ пробела, табуляции \t, перевода строки \n и некоторые другие редкие пробельные символы, обозначаемые как \v, \f и \r.
\w («w»: от английского «word» – «слово»)
Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание _. Нелатинские буквы не являются частью класса \w, то есть буква русского алфавита не подходит.
Для примера, \d\s\w обозначает «цифру», за которой идёт пробельный символ, а затем символ слова, например 1 a.

Регулярное выражение может содержать как обычные символы, так и символьные классы.\
Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре. «Обратный» означает, что он соответствует всем другим символам,

let str = "+7(903)-123-45-67";
alert( str.match(/\d/g).join('') );


В регулярном выражении можно искать символ с заданным свойством, указав его в \p{…}. Для таких регулярных выражений обязательно использовать флаг u.

let str = "A ბ ㄱ";
alert( str.match(/\p{L}/gu) ); // A,ბ,ㄱ

Вот основные категории символов и их подкатегории:

Буквы L:
в нижнем регистре Ll,
модификаторы Lm,
заглавные буквы Lt,
в верхнем регистре Lu,
прочие Lo.
Числа N:
десятичная цифра Nd,
цифры обозначаемые буквами (римские) Nl,
прочие No.
Знаки пунктуации P:
соединители Pc,
тире Pd,
открывающие кавычки Pi,
закрывающие кавычки Pf,
открывающие скобки Ps,
закрывающие скобки Pe,
прочее Po.
Отметки M (например, акценты):
двоеточия Mc,
вложения Me,
апострофы Mn.
Символы S:
валюты Sc,
модификаторы Sk,
математические Sm,
прочие So.
Разделители Z:
линия Zl,
параграф Zp,
пробел Zs.
Прочие C:
контрольные Cc,
форматирование Cf,
не назначенные Cn,
для приватного использования Co,
суррогаты Cs.

Шестнадцатеричная цифра может быть обозначена как \p{Hex_Digit}

let regexp = /\p{sc=Han}/gu; // вернёт китайские иероглифы
let str = `Hello Привет 你好 123_456`;
alert( str.match(regexp) ); // 你,好 SC - система написания


Символы, обозначающие валюты, такие как $, €, ¥, имеют свойство \p{Currency_Symbol}, короткая запись: \p{Sc}.
Флаг u включает поддержку Юникода в регулярных выражениях.

Конкретно, это означает, что:

Символы из 4 байт воспринимаются как единое целое, а не как два символа по 2 байта.
Работает поиск по Юникодным свойствам \p{…}.
С помощью Юникодных свойств мы можем искать слова на нужных языках, специальные символы (кавычки, обозначения валюты) и так далее.


У символов каретки ^ и доллара $ есть специальные значения в регулярных выражениях. Они называются «якоря» (anchors).

Каретка ^ означает совпадение с началом текста, а доллар $ – с концом.

К примеру, давайте проверим начинается ли текст с Mary:

let str1 = "Mary had a little lamb";
alert( /^Mary/.test(str1) ); // true


Аналогично можно проверить, кончается ли строка словом snow при помощи snow$:

let str1 = "it's fleece was white as snow";
alert( /snow$/.test(str1) ); // true
Оба якоря вместе ^...$ часто используются для проверки, совпадает ли строка с шаблоном полностью.


Многострочный режим включается флагом m.

Он влияет только на поведение ^ и $.

В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.
В примере ниже текст состоит из нескольких строк. Шаблон /^\d/gm берёт цифру с начала каждой строки:

let str = 1е место: Винни
2е место: Пятачок
3е место: Слонопотам;

console.log( str.match(/^\d/gm) ); // 1, 2, 3

Когда движок регулярных выражений (программный модуль, реализующий поиск по регулярным выражениям) видит \b, он проверяет, что позиция в строке является границей слова.

Есть три вида позиций, которые являются границами слова:

Начало текста, если его первый символ \w.
Позиция внутри текста, если слева находится \w, а справа – не \w, или наоборот.
Конец текста, если его последний символ \w.
Java!\b (восклицательный знак не является «символом слова» \w, поэтому после него нет границы слова).
Граница слова \b не работает для алфавитов, не основанных на латинице

Для поиска специальных символов [ ] \ ^ $ . | ? * + ( ), нам нужно добавить перед ними \ («экранировать их»).
Нам также нужно экранировать /, если мы используем /.../ (но не new RegExp).
При передаче строки в new RegExp нужно удваивать обратную косую черту: \\ для экранирования специальных символов, потому что строковые кавычки «съедят» одну черту

Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных».
Для примера, [eao] означает любой из 3-х символов: 'a', 'e' или 'o' ТОЛЬКО ОДНОМУ СИМВОЛУ

Ещё квадратные скобки могут содержать диапазоны символов.
К примеру, [a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5.
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF

[^…] Не то что в диапазоне

Чтобы указать количество повторений, нам нужно добавить квантификатор. Самый простой квантификатор — это число в фигурных скобках: {n}. Шаблон \d{5} обозначает ровно 5 цифр
Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}
alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234" Причём верхнюю границу можно не указывать

let str = "+7(903)-123-45-67";
let numbers = str.match(/\d{1,}/g);
alert(numbers); // 7,903,123,45,67

+ это «один или более». То же самое, что и {1,}.
? это «ноль или один». То же самое, что и {0,1}
* это «ноль или более». То же самое, что и {0,}.

Регулярное выражение для «открывающего или закрывающего HTML-тега без атрибутов»: /<\/?[a-z][a-z0-9]*>/i
Для каждой позиции в строке для поиска:
Попробовать найти совпадение с шаблоном на этой позиции.
Если нет совпадения, переход к следующей позиции.

let str = 'a "witch" and her "broom" is one';

alert( str.match(regexp) ); // "witch" and her "broom"
ДВИЖОК ЖАДНЫЙ, он видит точку и идёт до конца, а потом понимает что он мог перебрать и идёт назад

«Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».
Мы можем включить его, вставив знак вопроса '?' после квантификатора, то есть будет *? или +? или даже ?? для '?'.
Проясним: обычно знак вопроса ? сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый. В ленивом режиме движок будет искать сразу последний элемент

У квантификаторов есть два режима работы:

Жадный
По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз, сколько это возможно. Например, \d+ получит все возможные цифры. Когда цифры закончатся или он дойдёт до конца строки, движок продолжит искать совпадение для оставшегося шаблона. Если совпадения не будет, он уменьшит количество повторов (осуществит возврат) и попробует снова.
Ленивый
Включается с помощью знака вопроса ? после квантификатора. Движок регулярного выражения пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора.
Как мы увидели на примере поиска строк в кавычках, ленивый режим не «панацея» от всех проблем жадного поиска. В качестве альтернативы может выступать «хорошо настроенный» жадный поиск, как в шаблоне "[^"]+".
`
