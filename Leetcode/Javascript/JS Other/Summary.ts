`

ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ ПОПАПЫ 

Открыть что-то в другой вкладке (Попап)
window.open('https://javascript.info/')

Всплывающее окно блокируется в том случае, если вызов window.open произошёл не в результате действия посетителя (например, события onclick).

window.open(url, name, params)
params - Строка параметров для нового окна. Содержит настройки, разделённые запятыми. Важно помнить, что в данной строке не должно быть пробелов. Например width=200,height=100

Панели окна:
menubar (yes/no) – позволяет отобразить или скрыть меню браузера в новом окне.
toolbar (yes/no) – позволяет отобразить или скрыть панель навигации браузера (кнопки вперёд, назад, перезагрузки страницы) нового окна.
location (yes/no) – позволяет отобразить или скрыть адресную строку нового окна. Firefox и IE не позволяют скрывать эту панель по умолчанию.
status (yes/no) – позволяет отобразить или скрыть строку состояния. Как и с адресной строкой, большинство браузеров будут принудительно показывать её.
resizable (yes/no) – позволяет отключить возможность изменения размера нового окна. Не рекомендуется.
scrollbars (yes/no) – позволяет отключить полосы прокрутки для нового окна. Не рекомендуется.


Вызов open возвращает ссылку на новое окно. Эта ссылка может быть использована для управления свойствами окна, например, изменения положения
let newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write("Hello, world!");
Попап также может обратиться к открывшему его окну по ссылке window.opener. Она равна null для всех окон, кроме попапов
Чтобы закрыть окно: win.close()
Для проверки, закрыто ли окно: win.closed

win.moveBy(x,y)
Переместить окно относительно текущей позиции на x пикселей вправо и y пикселей вниз. Допустимы отрицательные значения (для перемещения окна влево и вверх).
win.moveTo(x,y)
Переместить окно на координаты экрана (x,y).
win.resizeBy(width,height)
Изменить размер окна на указанные значения width/height относительно текущего размера. Допустимы отрицательные значения.
win.resizeTo(width,height)
Изменить размер окна до указанных значений.

Всплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, а показать – в элементе <div>, расположенным над страницей (z-index). Ещё одна альтернатива – тег <iframe>.

Если мы открываем попап, хорошей практикой будет предупредить пользователя об этом. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения.

Новое окно можно открыть с помощью вызова open(url, name, params). Этот метод возвращает ссылку на это новое окно.
По умолчанию браузеры блокируют вызовы open, выполненные не в результате действий пользователя. Обычно браузеры показывают предупреждение, так что пользователь всё-таки может разрешить вызов этого метода.
Вместо попапа открывается вкладка, если в вызове open не указаны его размеры.
У попапа есть доступ к породившему его окну через свойство window.opener.
Если основное окно и попап имеют один домен и протокол, то они свободно могут читать и изменять друг друга. В противном случае, они могут только изменять положение друг друга и взаимодействовать с помощью сообщений.
Чтобы закрыть попап: метод close(). Также попап может закрыть и пользователь (как и любое другое окно). После закрытия окна свойство window.closed имеет значение true.

Методы focus() и blur() позволяют установить или убрать фокус с попапа. Но работают не всегда.
События focus и blur позволяют отследить получение и потерю фокуса новым окном. Но, пожалуйста, не забывайте, что окно может остаться видимым и после blur.

Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window
Мы можем обращаться к ним, используя свойства:
iframe.contentWindow ссылка на объект window внутри <iframe>.
iframe.contentDocument – ссылка на объект document внутри <iframe>, короткая запись для iframe.contentWindow.document

iframe sandbox="allow-scripts allow-forms"

Защита от взлома с помощью iframe - сделать невидимую обёртку перехватывающую все клики и если window == top то обёртку убираем
Заголовок с сервера X-Frame-Options: SAMEORIGIN

Атака сlickjacking – это способ хитростью «заставить» пользователей кликнуть на сайте-жертве, без понимания, что происходит. Она опасна, если по клику могут быть произведены важные действия.

Хакер может разместить ссылку на свою вредоносную страницу в сообщении или найти другие способы, как заманить пользователей. Вариантов множество.

С одной стороны — эта атака «неглубокая», ведь хакер перехватывает только один клик. Но с другой стороны, если хакер знает, что после этого клика появятся другие элементы управления, то он может хитростью заставить пользователя кликнуть на них.

Этот вид атаки довольно опасен, ведь при разработке интерфейсов мы не предполагаем, что хакер может кликнуть от имени пользователя. Поэтому уязвимости могут быть обнаружены в совершенно неожиданных местах.

Для защиты от этой атаки рекомендуется использовать X-Frame-Options: SAMEORIGIN на страницах или даже целиком сайтах, которые не предназначены для просмотра во фрейме.
Или, если мы хотим разрешить отображение страницы во фрейме и при этом оставаться в безопасности, то можно использовать перекрывающий блок <div>.

Если сайт, такой как Facebook, при установке авторизующего куки ставит атрибут samesite:

Set-Cookie: authorization=secret; samesite
… Тогда такие куки не будут отправляться, когда Facebook будет открыт в ифрейме с другого сайта. Так что атака не удастся.

так мы можем заменить домен документа чтобы считались имеющими один и тот же domen peter.site.com john.site.com
document.domain = 'site.com';
Документ в iframe находится не сразу

ПОЛУЧИТЬ iframe можно через 
Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:

По номеру: window.frames[0] – объект window для первого фрейма в документе.
По имени: window.frames.iframeName – объект window для фрейма со свойством name="iframeName".

window.frames – коллекция «дочерних» window (для вложенных фреймов).
window.parent – ссылка на «родительский» (внешний) window.
window.top – ссылка на самого верхнего родителя

Интерфейс postMessage позволяет окнам общаться между собой независимо от их происхождения.

Это способ обойти политику «Одинакового источника». Он позволяет обмениваться информацией, скажем john-smith.com и gmail.com, но только в том случае, если оба сайта согласны и вызывают соответствующие JavaScript-функции. Это делает общение безопасным для пользователя.

Чтобы получать сообщения, окно-получатель должно иметь обработчик события message (сообщение). Оно срабатывает, когда был вызван метод postMessage (и проверка targetOrigin пройдена успешно).

Чтобы вызвать метод или получить содержимое из другого окна, нам, во-первых, необходимо иметь ссылку на него.

Для всплывающих окон (попапов) доступны ссылки в обе стороны:

При открытии окна: window.open открывает новое окно и возвращает ссылку на него,
Изнутри открытого окна: window.opener – ссылка на открывающее окно.
Для ифреймов мы можем иметь доступ к родителям/потомкам, используя:

window.frames – коллекция объектов window вложенных ифреймов,
window.parent, window.top – это ссылки на родительское окно и окно самого верхнего уровня,
iframe.contentWindow – это объект window внутри тега <iframe>.
Если окна имеют одинаковый источник (протокол, домен, порт), то они могут делать друг с другом всё, что угодно.

В противном случае возможны только следующие действия:

Изменение свойства location другого окна (доступ только на запись).
Отправить туда сообщение.
Исключения:

Окна, которые имеют общий домен второго уровня: a.site.com и b.site.com. Установка свойства document.domain='site.com' в обоих окнах переведёт их в состояние «Одинакового источника».
Если у ифрейма установлен атрибут sandbox, это принудительно переведёт окна в состояние «разных источников», если не установить в атрибут значение allow-same-origin. Это можно использовать для запуска ненадёжного кода в ифрейме с того же сайта.
Метод postMessage позволяет общаться двум окнам с любыми источниками:

Отправитель вызывает targetWin.postMessage(data, targetOrigin).

Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWin источник targetOrigin.

Если это так, тогда targetWin вызывает событие message со специальными свойствами:

origin – источник окна отправителя (например, http://my.site.com)
source – ссылка на окно отправитель.
data – данные, может быть объектом везде, кроме IE (в IE только строки).
В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.
`



`
БИНАРНЫЕ ДАННЫЕ БИНАРНЫЕ ДАННЫЕ БИНАРНЫЕ ДАННЫЕ БИНАРНЫЕ ДАННЫЕ БИНАРНЫЕ ДАННЫЕ БИНАРНЫЕ ДАННЫЕ 

Базовый объект для работы с бинарными данными имеет тип ArrayBuffer и представляет собой ссылку на непрерывную область памяти фиксированной длины.
ArrayBuffer – это область памяти. Что там хранится? Этой информации нет. Просто необработанный («сырой») массив байтов.
Для работы с ArrayBuffer нам нужен специальный объект, реализующий «представление» данных.

Конструкторы типизированных массивов (будь то Int8Array или Float64Array, без разницы) ведут себя по-разному в зависимости от типа передаваемого им аргумента

Способы создания типизированных массивов
new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();

ОТБРАСЫВАЮТСЯ СТАРШИЕ БИТЫ ЕСЛИ НЕ ПОПАДАЕМ В КОЛ-ВО ОСТАЮТСЯ ПРАВЫЕ

Но зато есть два дополнительных метода:

arr.set(fromArr, [offset]) копирует все элементы из fromArr в arr, начиная с позиции offset (0 по умолчанию).
arr.subarray([begin, end]) создаёт новое представление того же типа для данных, начиная с позиции begin до end (не включая). Это похоже на метод slice (который также поддерживается), но при этом ничего не копируется – просто создаётся новое представление, чтобы совершать какие-то операции над указанными данными.


DataView – это специальное супергибкое нетипизированное представление данных из ArrayBuffer. Оно позволяет обращаться к данным на любой позиции и в любом формате.
В случае DataView доступ к данным осуществляется посредством методов типа .getUint8(i) или .getUint16(i). Мы выбираем формат данных в момент обращения к ним, а не в момент их создания.

new DataView(buffer, [byteOffset], [byteLength])

ArrayBuffer – это корневой объект, ссылка на непрерывную область памяти фиксированной длины.

Чтобы работать с объектами типа ArrayBuffer, нам нужно представление («view»).

Это может быть типизированный массивTypedArray:
Uint8Array, Uint16Array, Uint32Array – для беззнаковых целых по 8, 16 и 32 бита соответственно.
Uint8ClampedArray – для 8-битных беззнаковых целых, которые обрезаются по верхней и нижней границе при присвоении.
Int8Array, Int16Array, Int32Array – для знаковых целых чисел (могут быть отрицательными).
Float32Array, Float64Array – для 32- и 64-битных знаковых чисел с плавающей точкой.
Или DataView – представление, использующее отдельные методы, чтобы уточнить формат данных при обращении, например, getUint8(offset).
Обычно мы создаём и работаем с типизированными массивами, оставляя ArrayBuffer «под капотом». Но мы можем в любой момент получить к нему доступ с помощью .buffer и при необходимости создать другое представление.

Существуют ещё 2 дополнительных термина, которые используются в описаниях методов, работающих с бинарными данными:

ArrayBufferView – это общее название для представлений всех типов.
BufferSource – это общее название для ArrayBuffer или ArrayBufferView.
Мы встретимся с ними в следующих главах. BufferSource встречается очень часто и означает «бинарные данные в любом виде» – ArrayBuffer или его представление.
Встроенный объект TextDecoder позволяет декодировать данные из бинарного буфера в обычную строку.

let decoder = new TextDecoder([label], [options]);
label – тип кодировки, utf-8 используется по умолчанию, но также поддерживаются big5, windows-1251 и многие другие.
options – объект с дополнительными настройками:
fatal – boolean, если значение true, тогда генерируется ошибка для невалидных (не декодируемых) символов, в ином случае (по умолчанию) они заменяются символом \uFFFD.
ignoreBOM – boolean, если значение true, тогда игнорируется BOM (дополнительный признак, определяющий порядок следования байтов), что необходимо крайне редко.

let str = decoder.decode([input], [options]);
let uint8Array = new Uint8Array([72, 101, 108, 108, 111]);

alert( new TextDecoder().decode(uint8Array) ); // Hello
TextEncoder поступает наоборот – кодирует строку в бинарный массив.

let encoder = new TextEncoder();

let uint8Array = encoder.encode("Hello");
alert(uint8Array); // 72,101,108,108,111

let blob = new Blob(["<html>…</html>"], {type: 'text/html'});
Мы можем получить срез Blob, используя:
blob.slice([byteStart], [byteEnd], [contentType]);
Blob может быть использован как URL для <a>, <img> или других тегов, для показа содержимог
    <!-- download атрибут указывает браузеру делать загрузку вместо навигации -->
    <a download="hello.txt" href='#' id="link">Загрузить</a>
    <script>
    let blob = new Blob(["Hello, world!"], {type: 'text/plain'});
    link.href = URL.createObjectURL(blob);
    </script>

URL.revokeObjectURL(url) удаляет внутреннюю ссылку на объект, что позволяет удалить его (если нет другой ссылки) сборщику мусора, и память будет освобождена.

Операции с изображениями выполняются через элемент <canvas>:

Для отрисовки изображения (или его части) на холсте (canvas) используется canvas.drawImage.
Вызов canvas-метода .toBlob(callback, format, quality) создаёт Blob и вызывает функцию callback при завершении.

В то время как ArrayBuffer, Uint8Array и другие BufferSource являются «бинарными данными», Blob представляет собой «бинарные данные с типом».

Это делает Blob удобным для операций загрузки/выгрузки данных, которые так часто используются в браузере.

Методы, которые выполняют сетевые запросы, такие как XMLHttpRequest, fetch и подобные, могут изначально работать с Blob так же, как и с другими объектами, представляющими двоичные данные.

Мы можем легко конвертировать Blob в низкоуровневые бинарные типы данных и обратно:

Мы можем создать Blob из типизированного массива, используя конструктор new Blob(...).
Мы можем обратно создать ArrayBuffer из Blob, используя FileReader, а затем создать его представление для низкоуровневых операций.


<input type="file" onchange="showFile(this)">

<script>
function showFile(input) {
  let file = input.files[0];

  alert(File name: ${file.name}); // например, my.png
  alert(Last modified: ${file.lastModified}); // например, 1552830408824
}
</script>

FileReader объект, цель которого читать данные из Blob (и, следовательно, из File тоже)
let reader = new FileReader();
Основные методы:

readAsArrayBuffer(blob) – считать данные как ArrayBuffer
readAsText(blob, [encoding]) – считать данные как строку (кодировка по умолчанию: utf-8)
readAsDataURL(blob) – считать данные как base64-кодированный URL.
abort() – отменить операцию.
Выбор метода для чтения зависит от того, какой формат мы предпочитаем, как мы хотим далее использовать данные.

readAsArrayBuffer – для бинарных файлов, для низкоуровневой побайтовой работы с бинарными данными. Для высокоуровневых операций у File есть свои методы, унаследованные от Blob, например, slice, мы можем вызвать их напрямую.
readAsText – для текстовых файлов, когда мы хотим получить строку.
readAsDataURL – когда мы хотим использовать данные в src для img или другого тега. Есть альтернатива – можно не читать файл, а вызвать URL.createObjectURL(file), детали в главе Blob.
В процессе чтения происходят следующие события:

loadstart – чтение начато.
progress – срабатывает во время чтения данных.
load – нет ошибок, чтение окончено.
abort – вызван abort().
error – произошла ошибка.
loadend – чтение завершено (успешно или нет).
Когда чтение закончено, мы сможем получить доступ к его результату следующим образом:

reader.result результат чтения (если оно успешно)
reader.error объект ошибки (при неудаче).

File объекты наследуют от Blob.

Помимо методов и свойств Blob, объекты File также имеют свойства name и lastModified плюс внутреннюю возможность чтения из файловой системы. Обычно мы получаем объекты File из пользовательского ввода, например, через <input> или перетаскиванием с помощью мыши, в событии dragend.

Объекты FileReader могут читать из файла или Blob в одном из трёх форматов:

Строка (readAsText).
ArrayBuffer (readAsArrayBuffer).
URL в формате base64 (readAsDataURL).
Однако, во многих случаях нам не нужно читать содержимое файла. Как и в случае с Blob, мы можем создать короткий URL с помощью URL.createObjectURL(file) и использовать его в теге <a> или <img>. Таким образом, файл может быть загружен или показан в виде изображения, как часть canvas и т.д.

А если мы собираемся отправить File по сети, то это также легко, поскольку в сетевые методы, такие как XMLHttpRequest или fetch, встроена возможность отсылки File.
`

`
ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ ВЕБ КОМПОНЕНТЫ 

Существует два вида пользовательских элементов:

Автономные пользовательские элементы – «полностью новые» элементы, расширяющие абстрактный класс HTMLElement.
Пользовательские встроенные элементы – элементы, расширяющие встроенные, например кнопку HTMLButtonElement и т.п.

Новые теги можно создавать наследуя от HTMLElement и задав в этом классе некоторые параметры, далее мы регистрируем через
// сообщим браузеру, что <my-element> обслуживается нашим новым классом
customElements.define("my-element", MyElement);
Теперь для любых HTML-элементов с тегом <my-element> создаётся экземпляр MyElement и вызываются вышеупомянутые методы.
Имя пользовательского элемента должно содержать дефис -
Есть два типа пользовательских элементов:

«Автономные» – новые теги, расширяющие HTMLElement.

Схема определения:

class MyElement extends HTMLElement {
  constructor() { super(); /* ... */ }
  connectedCallback() { /* ... */ }
  disconnectedCallback() { /* ... */  }
  static get observedAttributes() { return [/* ... */]; }
  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
  adoptedCallback() { /* ... */ }
 }
customElements.define('my-element', MyElement);
/* <my-element> */
«Модифицированные встроенные элементы» – расширения существующих элементов.

Требуют ещё один аргумент в .define и атрибут is="..." в HTML:

class MyButton extends HTMLButtonElement { /*...*/ }
customElements.define('my-button', MyElement, {extends: 'button'});
/* <button is="my-button"> */
Пользовательские элементы широко поддерживаются среди браузеров. Существует полифил: https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs.

Сложные тэги, например input type range - уже содержат в себе элементы
Show user agent shadow DOM в хром
ИНКАПСУЛЯЦИЯ СТИЛЕЙ
Если у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево.

<script>
customElements.define('show-hello', class extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({mode: 'open'});
    shadow.innerHTML = <p>
      Hello, ${this.getAttribute('name')}
    </p>;
  }
});
</script>

Теневой DOM отделён от главного документа:

Элементы теневого DOM не видны из обычного DOM через querySelector. В частности, элементы теневого DOM могут иметь такие же идентификаторы, как у элементов в обычном DOM (light DOM). Они должны быть уникальными только внутри теневого дерева.
У теневого DOM свои стили. Стили из внешнего DOM не применятся.

Теневой DOM – это способ создать свой, изолированный, DOM для компонента.

shadowRoot = elem.attachShadow({mode: open|closed}) – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.
Мы можем создать подэлементы внутри shadowRoot с помощью innerHTML или других методов DOM.
Элементы теневого DOM:

Обладают собственной областью видимости идентификаторов
Невидимы JavaScript селекторам из главного документа, таким как querySelector,
Стилизуются своими стилями из теневого дерева, не из главного документа.
Теневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM). В главе Слоты теневого DOM, композиция мы разберём, как делать их композицию.

<show-hello name="John"></show-hello>


Подводим итоги:

Браузер не исправляет код в template, даже если он типо должен находится в определённом другом тэге

<template id="tmpl">
  <script>
    alert("Привет");
  </script>
  <div class="message">Привет, Мир!</div>
</template>

<script>
  let elem = document.createElement('div');

  // Клонируем содержимое шаблона для того, чтобы переиспользовать его несколько раз
  elem.append(tmpl.content.cloneNode(true));

  document.body.append(elem);
  // Сейчас скрипт из <template> выполнится
</script>

<template id="tmpl">
  <style> p { font-weight: bold; } </style>
  <p id="message"></p>
</template>

<div id="elem">Нажми на меня</div>

<script>
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

    elem.shadowRoot.getElementById('message').innerHTML = "Привет из теней!";
  };
</script>

Содержимым <template> может быть любой синтаксически корректный HTML.
Содержимое <template> считается находящимся «вне документа», поэтому оно ни на что не влияет.
Мы можем получить доступ к template.content из JavaScript, клонировать его и переиспользовать в новом компоненте.
Элемент <template> уникальный по следующим причинам:

Браузер проверяет правильность HTML-синтаксиса в нём (в отличие от строк в скриптах).
…При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например <tr>).
Его содержимое оживает (скрипты выполняются, <video autoplay> проигрывается и т. д.), когда помещается в документ.
Элемент <template> не поддерживает итерацию, связывания данных или подстановки переменных. Однако эти возможности можно реализовать поверх него.

Теневой DOM поддерживает элементы <slot>, которые автоматически наполняются контентом из обычного, «светлого» DOM-дерева.

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = 
      <div>Имя:
        <slot name="username"></slot>
      </div>
      <div>Дата рождения:
        <slot name="birthday"></slot>
      </div>
    ;
  }
});
</script>

<user-card>
  <span slot="username">Иван Иванов</span>
  <span slot="birthday">01.01.2001</span>
</user-card>

Атрибут slot="…" могут иметь только дети первого уровня
Браузер наблюдает за слотами и обновляет отображение при добавлении и удалении элементов в слотах.

Обычно, если у элемента есть теневое дерево, то содержимое обычного, светлого DOM не показывается. Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM.

Существует два вида слотов:

Именованные слоты: <slot name="X">...</slot> – получают элементы светлого DOM с slot="X".
Слот по умолчанию: первый <slot> без имени (последующие неименованные слоты игнорируются) – показывает элементы элементов светлого дерева, которые не находятся в других слотах.
Если одному слоту назначено несколько элементов, они добавляются один за другим.
Содержимое элемента <slot> используется как резервное. Оно отображается, если в слоте нет элементов из светлого дерева.
Процесс отображения элементов внутри слота называется «композицией». В результате композиции строится «развёрнутый DOM».

При композиции не происходит перемещения узлов – с точки зрения JavaScript, DOM остаётся прежним.

JavaScript может получить доступ к слотам с помощью следующих методов:

slot.assignedNodes/Elements() – возвращает узлы/элементы, которые находятся внутри slot.
node.assignedSlot – обратный метод, возвращает слот по узлу.
Если мы хотим знать, что показываем, мы можем отследить контент слота следующими способами:

событие slotchange – запускается, когда слот наполняется контентом в первый раз, и при каждой операции добавления/удаления/замещения элемента в слоте, за исключением его потомков. Сам слот будет event.target.
MutationObserver для более глубокого просмотра содержимого элемента в слоте и отслеживания изменений в нём.
Теперь, когда мы научились показывать элементы светлого DOM в теневом DOM, давайте посмотрим, как их правильно стилизовать. Основное правило звучит так: теневые элементы стилизуются внутри, а обычные элементы – снаружи; однако есть заметные исключения.

Теневой DOM может включать в себя стили, такие как <style> или <link rel="stylesheet">.

Локальные стили могут влиять на:

теневое дерево,
элемент-хозяин, при помощи псевдоклассов :host и :host(),
слотовые элементы (из светлого DOM), ::slotted(селектор) позволяет стилизовать сами слотовые элементы, но не их дочерние элементы.
Стили документов могут влиять на:

элемент-хозяин (так как он находится во внешнем документе)
слотовые элементы и их содержимое (так как они также физически присутствуют во внешнем документе)
Когда свойства CSS конфликтуют, обычно стили документа имеют приоритет, если только свойство не помечено как !important. Тогда предпочтение отдаётся локальным стилям.

Пользовательские свойства CSS проникают через теневой DOM. Они используются как «хуки» для придания элементам стиля:

Компонент использует пользовательское CSS-свойство для стилизации ключевых элементов, например var(--component-name-title, <значение по умолчанию>).
Автор компонента публикует эти свойства для разработчиков, они так же важны, как и другие общедоступные методы компонента.
Когда разработчик хочет стилизовать заголовок, он назначает CSS-свойство --component-name-title для элемента-хозяина или выше.
Profit!
Пользовательские свойства CSS существуют одновременно на всех уровнях, как светлом, так и в тёмном DOM.
События, которые произошли в теневом DOM, но пойманы снаружи этого DOM, имеют элемент-хозяин в качестве целевого элемента event.target

Только те события пересекают границы теневого DOM, у которых флаг composed установлен в значение true.

У большинства встроенных событий стоит composed: true, это описано в соответствующих спецификациях:

UI Events https://www.w3.org/TR/uievents.
Touch Events https://w3c.github.io/touch-events.
Pointer Events https://www.w3.org/TR/pointerevents.
…И так далее.
У некоторых встроенных событий всё же стоит composed: false:

mouseenter, mouseleave (вообще не всплывают),
load, unload, abort, error,
select,
slotchange.
Эти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву.

Если мы генерируем своё событие CustomEvent, то должны явно поставить флаг composed: true.

Обратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга. События с флагом composed всплывают через границы всех теневых DOM. Поэтому, если событие предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине и установить флаг composed: false. Тогда оно будет уже вне теневого DOM компонента, но не выплывает наружу в «ещё более внешний» DOM.
`

`
ХРАНЕНИЕ В БРАУЗЕРЕ ХРАНЕНИЕ В БРАУЗЕРЕ ХРАНЕНИЕ В БРАУЗЕРЕ ХРАНЕНИЕ В БРАУЗЕРЕ ХРАНЕНИЕ В БРАУЗЕРЕ

Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

Мы можем писать в document.cookie. Но это не просто свойство данных, а акcессор (геттер/сеттер). Присваивание к нему обрабатывается особым образом.

Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.

document.cookie = "user=John"; // обновляем только куки с именем 'user'
alert(document.cookie); // показываем все куки
Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию encodeURIComponent

Но это можно изменить. Если мы хотим разрешить поддоменам типа forum.site.com получать куки, установленные на site.com, это возможно.

Чтобы это произошло, при установке файла куки в site.com, мы должны явно установить параметр domain для корневого домена: domain=site.com. После этого все поддомены увидят такой файл cookie.

// находясь на странице site.com
// сделаем куки доступным для всех поддоменов *.site.com:
document.cookie = "user=John; domain=site.com"
samesite игнорируется (не поддерживается) старыми браузерами, выпущенными до 2017 года и ранее.

// возвращает куки с указанным name,
// или undefined, если ничего не найдено
function getCookie(name) {
  let matches = document.cookie.match(new RegExp(
    "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
  ));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
Операции обновления или удаления куки должны использовать те же путь и домен

Если мы загружаем скрипт со стороннего домена, например <script src="https://google-analytics.com/analytics.js">, и этот скрипт использует document.cookie, чтобы установить куки, то такое куки не является сторонним.

Если скрипт устанавливает куки, то нет разницы откуда был загружен скрипт – куки принадлежит домену текущей веб-страницы.

document.cookie предоставляет доступ к куки.

Операция записи изменяет только то куки, которое было указано.
Имя и значение куки должны быть закодированы.
Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).
Настройки куки:

path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
secure делает куки доступным только при использовании HTTPS.
samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.
Дополнительно:

Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.

Local storage един для комбинации домен/протокол/порт
Объекты хранилища localStorage и sessionStorage предоставляют одинаковые методы и свойства:

setItem(key, value) – сохранить пару ключ/значение.
getItem(key) – получить данные по ключу key.
removeItem(key) – удалить данные с ключом key.
clear() – удалить всё.
key(index) – получить ключ на заданной позиции.
length – количество элементов в хранилище.

for(let i=0; i<localStorage.length; i++) {
  let key = localStorage.key(i);
  alert(${key}: ${localStorage.getItem(key)});
}

Свойства и методы такие же, но есть существенные ограничения:
sessionStorage существует только в рамках текущей вкладки браузера.
Другая вкладка с той же страницей будет иметь другое хранилище.
Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

key и value должны быть строками.
Лимит 5 Мб+, зависит от браузера.
Данные не имеют «времени истечения».
Данные привязаны к источнику (домен/протокол/порт).
localStorage	sessionStorage
Совместно используется между всеми вкладками и окнами с одинаковым источником	Разделяется в рамках вкладки браузера, среди ифреймов из того же источника
«Переживает» перезапуск браузера	«Переживает» перезагрузку страницы (но не закрытие вкладки)
API:

setItem(key, value) – сохранить пару ключ/значение.
getItem(key) – получить данные по ключу key.
removeItem(key) – удалить значение по ключу key.
clear() – удалить всё.
key(index) – получить ключ на заданной позиции.
length – количество элементов в хранилище.
Используйте Object.keys для получения всех ключей.
Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событиеstorage не срабатывает.
Событие storage:

Срабатывает при вызове setItem, removeItem, clear.
Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.
Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).

> Js:
let openRequest = indexedDB.open(name, version);

> Js:
После этого вызова необходимо назначить обработчик событий для объекта openRequest:

success: база данных готова к работе, готов «объект базы данных» openRequest.result, его следует использовать для дальнейших вызовов.
error: не удалось открыть базу данных.
upgradeneeded: база открыта, но её схема устарела (см. ниже).

> Js:
let openRequest = indexedDB.open("store", 2); openRequest.onupgradeneeded = function(event) { // версия существующей базы данных меньше 2 (или база данных не существует) let db = openRequest.result; switch(event.oldVersion) { // существующая (старая) версия базы данных case 0: // версия 0 означает, что на клиенте нет базы данных // выполнить инициализацию case 1: // на клиенте версия базы данных 1 // обновить } };

> Js:
let deleteRequest = indexedDB.deleteDatabase(name) // deleteRequest.onsuccess/onerror

> Js:
Если у нас уже открыта вкладка со страницей и мы открываем новую в которой обновляем версию, то нужно закрыть все другие моединения так как база едина для всех страниц. let openRequest = indexedDB.open("store", 2); openRequest.onupgradeneeded = ...; openRequest.onerror = ...; openRequest.onsuccess = function() { let db = openRequest.result; db.onversionchange = function() { db.close(); alert("База данных устарела, пожалуйста, перезагрузите страницу.") }; // ...база данных готова, используйте ее... }; openRequest.onblocked = function() { // это событие не должно срабатывать, если мы правильно обрабатываем onversionchange // это означает, что есть ещё одно открытое соединение с той же базой данных // и он не был закрыт после того, как для него сработал db.onversionchange };

> Js:
Мы можем хранить почти любое значение, в том числе сложные объекты.

> Js:
Каждому значению в хранилище должен соответствовать уникальный ключ.

Ключ должен быть одним из следующих типов: number, date, string, binary или array

> Js:
db.createObjectStore(name[, keyOptions]); - создание хранилища объектов

> Js:
db.createObjectStore('books', {keyPath: 'id'}); keyPath - это свойство объектов которое будет использоваться в качестве ключа

> Js:
Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в обработчике upgradeneeded

> Js:
db.deleteObjectStore('books')

> Js:
Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций. (то есть с гарантией, что все составные части будут 100 процентов выполнены)

> Js:
Добавление в хранилище результата транзакции let transaction = db.transaction("books", "readwrite"); // (1) // получить хранилище объектов для работы с ним let books = transaction.objectStore("books"); // (2) let book = { id: 'js', price: 10, created: new Date() }; let request = books.add(book); // (3) request.onsuccess = function() { // (4) console.log("Книга добавлена в хранилище", request.result); }; request.onerror = function() { console.log("Ошибка", request.error); };

> Js:
put/add отличие в том что если уже есть ключ то add выбросит ошибку

> Js:
Когда все запросы завершены и очередь микрозадач пуста, тогда транзакция завершится автоматически.

> Js:
Нельзя делать асинхронные операции после объявления транзакции, так как она закроетчя так как она автоматически закрывается после выполнения всех микрозадач, а фетч - это асинхронная макрозадача

> Js:
transaction.abort() - если что-то пойдет не так отменит уже сделанные изменения

> Js:
request.onerror следует вызвать event.preventDefault() если нужно не полностью отменять результат

> Js:
Есть два основных вида поиска в хранилище объектов:

По значению ключа или диапазону ключей. В нашем хранилище «books» это будет значение или диапазон значений book.id.
С помощью другого поля объекта, например book.price. Для этого потребовалась дополнительная структура данных, получившая название «index».

> Js:
Создание диапазонов IDBKeyRange.lowerBound(lower, [open]) означает: >lower (или ≥lower, если open это true)
IDBKeyRange.upperBound(upper, [open]) означает: <upper (или ≤upper, если open это true)
IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen]) означает: между lower и upper, включительно, если соответствующий open равен true.
IDBKeyRange.only(key) – диапазон, который состоит только из одного

> Js:
store.get(query) – поиск первого значения по ключу или по диапазону.
store.getAll([query], [count]) – поиск всех значений, можно ограничить, передав count.
store.getKey(query) – поиск первого ключа, который удовлетворяет запросу, обычно передаётся диапазон.
store.getAllKeys([query], [count]) – поиск всех ключей, которые удовлетворяют запросу, обычно передаётся диапазон, возможно ограничить поиск, передав count.
store.count([query]) – получить общее количество ключей, которые удовлетворяют запросу, обычно передаётся диапазон

> Js:
Хранилище объектов всегда отсортировано

> Js:
Для поиска по НЕ КЛЮЧУ objectStore.createIndex(name, keyPath, [options]);
name – название индекса,
keyPath – путь к полю объекта, которое индекс должен отслеживать (мы собираемся сделать поиск по этому полю),
option – необязательный объект со свойствами:
unique – если true, тогда в хранилище может быть только один объект с заданным значением в keyPath. Если мы попытаемся добавить дубликат, то индекс сгенерирует ошибку.
multiEntry – используется только, если keyPath является массивом. В этом случае, по умолчанию, индекс обрабатывает весь массив как ключ. Но если мы укажем true в multiEntry, тогда индекс будет хранить список объектов хранилища для каждого значения в этом массиве. Таким образом, элементы массива становятся ключами индекса.

> Js:
openRequest.onupgradeneeded = function() {
  // мы должны создать индекс здесь, в versionchange транзакции
  let books = db.createObjectStore('books', {keyPath: 'id'});
  let index = books.createIndex('price_idx', 'price');
};

> Js:
🖼 Photo

> Js:
А когда нужно найти применяем те же самые методы поиска но по индексу

> Js:
books.clear(); // очищаем хранилище.

> Js:
Объект cursor идёт по хранилищу объектов с заданным запросом (query) и возвращает пары ключ/значение по очереди, а не все сразу. Это позволяет экономить память.

> Js:
Использование курсора let transaction = db.transaction("books"); let books = transaction.objectStore("books"); let request = books.openCursor(); // вызывается для каждой найденной курсором книги request.onsuccess = function() { let cursor = request.result; if (cursor) { let key = cursor.key; // ключ книги (поле id) let value = cursor.value; // объект книги console.log(key, value); cursor.continue(); } else { console.log("Книг больше нет"); } };

> Js:
Код с просим обёрткой let db = await idb.openDb('store', 1, db => { if (db.oldVersion == 0) { // выполняем инициализацию db.createObjectStore('books', {keyPath: 'id'}); } }); let transaction = db.transaction('books', 'readwrite'); let books = transaction.objectStore('books'); try { await books.add(...); await books.add(...); await transaction.complete; console.log('сохранено'); } catch(err) { console.log('ошибка', err.message); }
`