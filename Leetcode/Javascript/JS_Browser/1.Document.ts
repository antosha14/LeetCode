`
DOM – это представление HTML-документа в виде дерева тегов
1. document – «входная точка» в DOM.
2. Узлы элементы - Теги являются узлами-элементами
3. Текстовые узлы - Текст внутри элементов. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем
4. Узел комментарий
Все, что есть в HTML, даже комментарии, является частью DOM. Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед <html>
`

`function sayHi() {
  alert("Hello");
}

// глобальные функции доступны как методы глобального объекта:
window.sayHi();
alert(window.innerHeight); // внутренняя высота окна браузера
`

`
Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, document.body – объект для тега <body>
Объект document – основная «входная точка».
// заменим цвет фона на красный,
document.body.style.background = "red";

// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);
Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д
Текст внутри элементов образует текстовые узлы

Пробелы и переносы строк тоже образуют текстовые узлы.
Существует всего два исключения из этого правила:
По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body, поскольку спецификация HTML требует, чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body> не может быть никаких пробелов.
Пробелы по краям строк и пробельные текстовые узлы скрыты в инструментах разработки
При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.
Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть <tbody>, но в HTML их можно написать (официально) без него.
`

`
Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
Например:
Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.

alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}
`

`
В кнсоли в браузере Последний элемент, выбранный во вкладке Elements, доступен в консоли как $0; предыдущий, выбранный до него, как $1 и т.д. Теперь мы можем запускать на них команды. Например $0.style.background = 'red' сделает выбранный элемент красным
`

`
Навигация и доступ к элементам
<html> = document.documentElement
<body> = document.body. НО Есть одна тонкость: document.body может быть равен null. В частности, если скрипт находится в <head>, document.body в нём недоступен, потому что браузер его ещё не прочитал.
<head> = document.head

ДЛЯ ВСЕХ НОДОВ
div.parentNode
div.previousSibling
div.nextSibling
div.childNodes Коллекция childNodes содержит список всех детей, включая текстовые узлы.
div.firstChild
div.lastChild
elem.hasChildNodes()
В мире DOM null означает «не существует»

ТОЛЬКО ДЛЯ НОДОВ ЭЛЕМЕНТОВ
div.parentElement
div.previousElementSibling
div.nextElementSibling
div.firstElementChild
div.lastElementChild
`

`
  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
`

`
Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив
1. Для перебора коллекции мы можем использовать for..of
2. Методы массивов не будут работать, потому что коллекция – это не массив (Array.from(pseudo))
DOM-коллекции – только для чтения НЕЛЬЗЯ ЧЕРЕЗ НИХ МЕНЯТЬ НОДЫ НА ДРУГИЕ
DOM-коллекции живые - ОТРАЖАЮТ ПОСЛЕДНЕЕ СОСТОЯНИЕ DOM
Не используйте цикл for..in для перебора коллекций
Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.
Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает кучу других свойств
`

`
document.getElementById
elem.querySelectorAll('ul > li:last-child') //Поиск всех по css селектору НО ВОЗВРАЩАЕТ ФИКСИРОВАННУЮ КОЛЛЕКЦИЮ
elem.querySelector // Одиночный
elem.matches(css) // Проверяет удовлетворяет ли элемент css селектору
elem.closest(css) //ищет ближайшего предка, который соответствует CSS-селектору
elem.getElementsByTagName(tag)
elem.getElementsByClassName(className)
document.getElementsByName(name)


Также есть глобальная переменная с именем, указанным в id
<div id="elem">Элемент</div>
elem.style.background = 'red'; Пожалуйста, не используйте такие глобальные переменные для доступа к элементам 
Значение id должно быть уникальным
`

`
Каждый DOM-узел принадлежит соответствующему встроенному классу.
Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.
Event Target - основа для ивентов
Node - основа для базы childNodes и т.д(не создаётся)
DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

Свойство tagName есть только у элементов Element.
Свойство nodeName определено для любых узлов Node:
для элементов оно равно tagName.
для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
document.body.innerHTML
`

`
Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.
Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
Мы можем писать в elem.outerHTML, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data
Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>
Технически, hidden работает так же, как style="display:none". Но его применение проще.
`