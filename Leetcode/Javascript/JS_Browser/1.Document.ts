`
DOM – это представление HTML-документа в виде дерева тегов
1. document – «входная точка» в DOM.
2. Узлы элементы - Теги являются узлами-элементами
3. Текстовые узлы - Текст внутри элементов. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем
4. Узел комментарий
Все, что есть в HTML, даже комментарии, является частью DOM. Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед <html>
`

`function sayHi() {
  alert("Hello");
}

// глобальные функции доступны как методы глобального объекта:
window.sayHi();
alert(window.innerHeight); // внутренняя высота окна браузера
`

`
Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, document.body – объект для тега <body>
Объект document – основная «входная точка».
// заменим цвет фона на красный,
document.body.style.background = "red";

// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);
Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д
Текст внутри элементов образует текстовые узлы

Пробелы и переносы строк тоже образуют текстовые узлы.
Существует всего два исключения из этого правила:
По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body, поскольку спецификация HTML требует, чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body> не может быть никаких пробелов.
Пробелы по краям строк и пробельные текстовые узлы скрыты в инструментах разработки
При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.
Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть <tbody>, но в HTML их можно написать (официально) без него.
`

`
Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
Например:
Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.

alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}
`

`
В кнсоли в браузере Последний элемент, выбранный во вкладке Elements, доступен в консоли как $0; предыдущий, выбранный до него, как $1 и т.д. Теперь мы можем запускать на них команды. Например $0.style.background = 'red' сделает выбранный элемент красным
`

`
Навигация и доступ к элементам
<html> = document.documentElement
<body> = document.body. НО Есть одна тонкость: document.body может быть равен null. В частности, если скрипт находится в <head>, document.body в нём недоступен, потому что браузер его ещё не прочитал.
<head> = document.head

ДЛЯ ВСЕХ НОДОВ
div.parentNode
div.previousSibling
div.nextSibling
div.childNodes Коллекция childNodes содержит список всех детей, включая текстовые узлы.
div.firstChild
div.lastChild
elem.hasChildNodes()
В мире DOM null означает «не существует»

ТОЛЬКО ДЛЯ НОДОВ ЭЛЕМЕНТОВ
div.parentElement
div.previousElementSibling
div.nextElementSibling
div.firstElementChild
div.lastElementChild
`

`
  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
`

`
Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив
1. Для перебора коллекции мы можем использовать for..of
2. Методы массивов не будут работать, потому что коллекция – это не массив (Array.from(pseudo))
DOM-коллекции – только для чтения НЕЛЬЗЯ ЧЕРЕЗ НИХ МЕНЯТЬ НОДЫ НА ДРУГИЕ
DOM-коллекции живые - ОТРАЖАЮТ ПОСЛЕДНЕЕ СОСТОЯНИЕ DOM
Не используйте цикл for..in для перебора коллекций
Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.
Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает кучу других свойств
`

`
document.getElementById
elem.querySelectorAll('ul > li:last-child') //Поиск всех по css селектору НО ВОЗВРАЩАЕТ ФИКСИРОВАННУЮ КОЛЛЕКЦИЮ
elem.querySelector // Одиночный
elem.matches(css) // Проверяет удовлетворяет ли элемент css селектору
elem.closest(css) //ищет ближайшего предка, который соответствует CSS-селектору
elem.getElementsByTagName(tag)
elem.getElementsByClassName(className)
document.getElementsByName(name)


Также есть глобальная переменная с именем, указанным в id
<div id="elem">Элемент</div>
elem.style.background = 'red'; Пожалуйста, не используйте такие глобальные переменные для доступа к элементам 
Значение id должно быть уникальным
`

`
Каждый DOM-узел принадлежит соответствующему встроенному классу.
Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.
Event Target - основа для ивентов
Node - основа для базы childNodes и т.д(не создаётся)
DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

Свойство tagName есть только у элементов Element.
Свойство nodeName определено для любых узлов Node:
для элементов оно равно tagName.
для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
document.body.innerHTML
`

`
Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.
Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
Мы можем писать в elem.outerHTML, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data
Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>
Технически, hidden работает так же, как style="display:none". Но его применение проще.
`

`
Конечно. Все атрибуты доступны с помощью следующих методов:

elem.hasAttribute(name) – проверяет наличие атрибута.
elem.getAttribute(name) – получает значение атрибута.
elem.setAttribute(name, value) – устанавливает значение атрибута.
elem.removeAttribute(name) – удаляет атрибут.

У HTML-атрибутов есть следующие особенности:
Их имена регистронезависимы (id то же самое, что и ID).
Их значения всегда являются строками.
Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
<body data-about="Elephants">
<script>
  alert(document.body.dataset.about); // Elephants
</script>
Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState.
`

`
let div = document.createElement('div');
let textNode = document.createTextNode('А вот и я');
document.body.append(div)
Вот методы для различных вариантов вставки:
node.append(...nodes or strings) – добавляет узлы или строки в конец node,
node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
node.before(...nodes or strings) –- вставляет узлы или строки до node,
node.after(...nodes or strings) –- вставляет узлы или строки после node,
node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.
div.remove()
Все методы вставки автоматически удаляют узлы со старых мест.

Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
`

`
document.body.classList.add('article');
Методы classList:
elem.classList.add/remove("class") – добавить/удалить класс.
elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада.
getComputedStyle(element, [pseudo]) //Получить скалькулированные стили

Есть две концепции в CSS:
Вычисленное (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования. Например, height:1em или font-size:125%.
Окончательное (resolved) значение – непосредственно применяемое к элементу. Значения 1em или 125% являются относительными. Браузер берёт вычисленное значение и делает все единицы измерения фиксированными и абсолютными, например, height:20px или font-size:16px. Для геометрических свойств разрешённые значения могут иметь плавающую точку, например, width:50.5px.

Свойства offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent.
`

`
scrollWidth/Height
Эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.
scrollLeft/scrollTop - Для задачи прокрутики элемента
Чтобы получить ширину/высоту окна, можно взять свойства clientWidth/clientHeight
`


`
Чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:
let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

`

`
Обычные элементы хранят текущее состояние прокрутки в elem.scrollLeft/scrollTop
Текущая прокрутка страницы window.pageXOffset/pageYOffset
Для прокрутки страницы из JavaScript её DOM должен быть полностью построен.
Обычные элементы можно прокручивать, изменяя scrollTop/scrollLeft.
Мы можем сделать то же самое для страницы в целом, используя document.documentElement.scrollTop/Left (кроме основанных на старом WebKit (Safari), где, как сказано выше, document.body.scrollTop/Left).
window.scrollBy(x,y) и window.scrollTo(pageX,pageY).

Для полноты картины давайте рассмотрим ещё один метод: elem.scrollIntoView(top).
Вызов elem.scrollIntoView(top) прокручивает страницу, чтобы elem оказался вверху. У него есть один аргумент:
если top=true (по умолчанию), то страница будет прокручена, чтобы elem появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна.
если top=false, то страница будет прокручена, чтобы elem появился внизу. Нижний край элемента будет совмещён с нижним краем окна
`

`
Метод elem.getBoundingClientRect() возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент elem
Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:

Относительно окна браузера – как position:fixed, отсчёт идёт от верхнего левого угла окна.
мы будем обозначать эти координаты как clientX/clientY, причина выбора таких имён будет ясна позже, когда мы изучим свойства событий.
Относительно документа – как position:absolute на уровне документа, отсчёт идёт от верхнего левого угла документа.
мы будем обозначать эти координаты как pageX/pageY

Метод elem.getBoundingClientRect() возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.

Основные свойства объекта типа DOMRect:
x/y – X/Y-координаты начала прямоугольника относительно окна,
width/height – ширина/высота прямоугольника (могут быть отрицательными).
Дополнительные, «зависимые», свойства:
top/bottom – Y-координата верхней/нижней границы прямоугольника,
left/right – X-координата левой/правой границы прямоугольника.
`


`
Чтобы показать что-то около нужного элемента, мы можем вызвать getBoundingClientRect, чтобы получить его координаты, а затем использовать CSS-свойство position вместе с left/top (или right/bottom).
Функция getCoords(elem) берёт координаты в контексте окна с помощью elem.getBoundingClientRect() и добавляет к ним значение соответствующей прокрутки:

// получаем координаты элемента в контексте документа
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
Если бы в примере выше мы использовали её вместе с position:absolute, то при прокрутке сообщение оставалось бы рядом с элементом.

Модифицированная функция createMessageUnder:

function createMessageUnder(elem, html) {
  let message = document.createElement('div');
  message.style.cssText = "position:absolute; color: red";

  let coords = getCoords(elem);

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
`